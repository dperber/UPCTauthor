/*
 * generated by Xtext 2.12.0
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.services.UpctformaGrammarAccess;
import upctforma.Column;
import upctforma.Composite;
import upctforma.CompositeType;
import upctforma.ContentDefinition;
import upctforma.ContentElement;
import upctforma.Field;
import upctforma.FieldValue;
import upctforma.Game;
import upctforma.Image;
import upctforma.Import;
import upctforma.ListType;
import upctforma.ListValue;
import upctforma.Paragraph;
import upctforma.PlaceHolder;
import upctforma.RecordType;
import upctforma.RecordValue;
import upctforma.Row;
import upctforma.Section;
import upctforma.SimpleElement;
import upctforma.SimpleType;
import upctforma.TemplateDef;
import upctforma.Text;
import upctforma.Type;
import upctforma.Unit;
import upctforma.UpctformaPackage;
import upctforma.UseTemplate;
import upctforma.Video;
import upctforma.Widget;
import upctforma.WidgetType;

@SuppressWarnings("all")
public class UpctformaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UpctformaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == UpctformaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UpctformaPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case UpctformaPackage.COMPOSITE:
				sequence_Composite_Impl(context, (Composite) semanticObject); 
				return; 
			case UpctformaPackage.COMPOSITE_TYPE:
				sequence_CompositeType_Impl(context, (CompositeType) semanticObject); 
				return; 
			case UpctformaPackage.CONTENT_DEFINITION:
				sequence_ContentDefinition(context, (ContentDefinition) semanticObject); 
				return; 
			case UpctformaPackage.CONTENT_ELEMENT:
				sequence_ContentElement_Impl(context, (ContentElement) semanticObject); 
				return; 
			case UpctformaPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case UpctformaPackage.FIELD_VALUE:
				sequence_FieldValue(context, (FieldValue) semanticObject); 
				return; 
			case UpctformaPackage.GAME:
				sequence_Game(context, (Game) semanticObject); 
				return; 
			case UpctformaPackage.IMAGE:
				sequence_Image(context, (Image) semanticObject); 
				return; 
			case UpctformaPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case UpctformaPackage.LIST_TYPE:
				sequence_ListType(context, (ListType) semanticObject); 
				return; 
			case UpctformaPackage.LIST_VALUE:
				sequence_ListValue(context, (ListValue) semanticObject); 
				return; 
			case UpctformaPackage.PARAGRAPH:
				sequence_Paragraph(context, (Paragraph) semanticObject); 
				return; 
			case UpctformaPackage.PLACE_HOLDER:
				sequence_PlaceHolder(context, (PlaceHolder) semanticObject); 
				return; 
			case UpctformaPackage.RECORD_TYPE:
				sequence_RecordType(context, (RecordType) semanticObject); 
				return; 
			case UpctformaPackage.RECORD_VALUE:
				sequence_RecordValue(context, (RecordValue) semanticObject); 
				return; 
			case UpctformaPackage.ROW:
				sequence_Row(context, (Row) semanticObject); 
				return; 
			case UpctformaPackage.SECTION:
				sequence_Section(context, (Section) semanticObject); 
				return; 
			case UpctformaPackage.SIMPLE_ELEMENT:
				sequence_SimpleElement_Impl(context, (SimpleElement) semanticObject); 
				return; 
			case UpctformaPackage.SIMPLE_TYPE:
				sequence_SimpleType(context, (SimpleType) semanticObject); 
				return; 
			case UpctformaPackage.TEMPLATE_DEF:
				sequence_TemplateDef(context, (TemplateDef) semanticObject); 
				return; 
			case UpctformaPackage.TEXT:
				sequence_Text(context, (Text) semanticObject); 
				return; 
			case UpctformaPackage.TYPE:
				sequence_Type_Impl(context, (Type) semanticObject); 
				return; 
			case UpctformaPackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case UpctformaPackage.USE_TEMPLATE:
				sequence_UseTemplate(context, (UseTemplate) semanticObject); 
				return; 
			case UpctformaPackage.VIDEO:
				sequence_Video(context, (Video) semanticObject); 
				return; 
			case UpctformaPackage.WIDGET:
				sequence_Widget(context, (Widget) semanticObject); 
				return; 
			case UpctformaPackage.WIDGET_TYPE:
				sequence_WidgetType(context, (WidgetType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ContentElement returns Column
	 *     Column returns Column
	 *
	 * Constraint:
	 *     (width=EString? (elements+=ContentElement elements+=ContentElement*)?)
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns CompositeType
	 *     CompositeType returns CompositeType
	 *     CompositeType_Impl returns CompositeType
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_CompositeType_Impl(ISerializationContext context, CompositeType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompositeType_ImplAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Composite
	 *     Composite_Impl returns Composite
	 *
	 * Constraint:
	 *     {Composite}
	 */
	protected void sequence_Composite_Impl(ISerializationContext context, Composite semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentDefinition returns ContentDefinition
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         name=QualifiedName? 
	 *         (imports+=Import imports+=Import*)? 
	 *         (types+=Type types+=Type*)? 
	 *         (templates+=TemplateDef templates+=TemplateDef*)? 
	 *         unit=Unit?
	 *     )
	 */
	protected void sequence_ContentDefinition(ISerializationContext context, ContentDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns ContentElement
	 *     ContentElement_Impl returns ContentElement
	 *
	 * Constraint:
	 *     {ContentElement}
	 */
	protected void sequence_ContentElement_Impl(ISerializationContext context, ContentElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FieldValue returns FieldValue
	 *
	 * Constraint:
	 *     (name=EString fieldvalue=ContentElement)
	 */
	protected void sequence_FieldValue(ISerializationContext context, FieldValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.FIELD_VALUE__FIELDVALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.FIELD_VALUE__FIELDVALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldValueAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFieldValueAccess().getFieldvalueContentElementParserRuleCall_2_0(), semanticObject.getFieldvalue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (name=EString fieldtype=[Type|EPrimitiveTypes])
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.FIELD__FIELDTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.FIELD__FIELDTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFieldAccess().getFieldtypeTypeEPrimitiveTypesParserRuleCall_2_0_1(), semanticObject.eGet(UpctformaPackage.Literals.FIELD__FIELDTYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Game
	 *     Game returns Game
	 *
	 * Constraint:
	 *     id=EString?
	 */
	protected void sequence_Game(ISerializationContext context, Game semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Image
	 *     Image returns Image
	 *
	 * Constraint:
	 *     url=EString?
	 */
	protected void sequence_Image(ISerializationContext context, Image semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ListType
	 *     CompositeType returns ListType
	 *     ListType returns ListType
	 *
	 * Constraint:
	 *     (name=EString listtype=[Type|EPrimitiveTypes])
	 */
	protected void sequence_ListType(ISerializationContext context, ListType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.LIST_TYPE__LISTTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.LIST_TYPE__LISTTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getListTypeAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getListTypeAccess().getListtypeTypeEPrimitiveTypesParserRuleCall_3_0_1(), semanticObject.eGet(UpctformaPackage.Literals.LIST_TYPE__LISTTYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns ListValue
	 *     ListValue returns ListValue
	 *
	 * Constraint:
	 *     (listvalues+=ContentElement listvalues+=ContentElement*)
	 */
	protected void sequence_ListValue(ISerializationContext context, ListValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Paragraph returns Paragraph
	 *
	 * Constraint:
	 *     text=EString?
	 */
	protected void sequence_Paragraph(ISerializationContext context, Paragraph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns PlaceHolder
	 *     PlaceHolder returns PlaceHolder
	 *
	 * Constraint:
	 *     type=[Type|EPrimitiveTypes]
	 */
	protected void sequence_PlaceHolder(ISerializationContext context, PlaceHolder semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.PLACE_HOLDER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.PLACE_HOLDER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlaceHolderAccess().getTypeTypeEPrimitiveTypesParserRuleCall_1_0_1(), semanticObject.eGet(UpctformaPackage.Literals.PLACE_HOLDER__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns RecordType
	 *     CompositeType returns RecordType
	 *     RecordType returns RecordType
	 *
	 * Constraint:
	 *     (name=EString recordtype+=Field recordtype+=Field*)
	 */
	protected void sequence_RecordType(ISerializationContext context, RecordType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns RecordValue
	 *     RecordValue returns RecordValue
	 *
	 * Constraint:
	 *     (recordvalues+=FieldValue recordvalues+=FieldValue*)
	 */
	protected void sequence_RecordValue(ISerializationContext context, RecordValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Row
	 *     Row returns Row
	 *
	 * Constraint:
	 *     ((columns+=Column columns+=Column*)? usetemplate=UseTemplate?)
	 */
	protected void sequence_Row(ISerializationContext context, Row semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns Section
	 *
	 * Constraint:
	 *     (name=EString image=EString? title=EString? (rows+=Row rows+=Row*)?)
	 */
	protected void sequence_Section(ISerializationContext context, Section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns SimpleElement
	 *     SimpleElement_Impl returns SimpleElement
	 *
	 * Constraint:
	 *     {SimpleElement}
	 */
	protected void sequence_SimpleElement_Impl(ISerializationContext context, SimpleElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns SimpleType
	 *     SimpleType returns SimpleType
	 *
	 * Constraint:
	 *     name=PrimitiveTypes
	 */
	protected void sequence_SimpleType(ISerializationContext context, SimpleType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleTypeAccess().getNamePrimitiveTypesTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TemplateDef returns TemplateDef
	 *
	 * Constraint:
	 *     (name=EString (rows+=Row rows+=Row*)?)
	 */
	protected void sequence_TemplateDef(ISerializationContext context, TemplateDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Text
	 *     Text returns Text
	 *
	 * Constraint:
	 *     (paragraphs+=Paragraph paragraphs+=Paragraph*)
	 */
	protected void sequence_Text(ISerializationContext context, Text semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *     Type_Impl returns Type
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_Type_Impl(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_ImplAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (name=EString author=EString sections+=Section sections+=Section*)
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UseTemplate returns UseTemplate
	 *
	 * Constraint:
	 *     (typetemplate=[TemplateDef|EString]? (templateelements+=ContentElement templateelements+=ContentElement*)?)
	 */
	protected void sequence_UseTemplate(ISerializationContext context, UseTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Video
	 *     Video returns Video
	 *
	 * Constraint:
	 *     id=EString?
	 */
	protected void sequence_Video(ISerializationContext context, Video semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns WidgetType
	 *     WidgetType returns WidgetType
	 *
	 * Constraint:
	 *     (name=EString widgettypeelements+=[Type|EPrimitiveTypes] widgettypeelements+=[Type|EPrimitiveTypes]*)
	 */
	protected void sequence_WidgetType(ISerializationContext context, WidgetType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Widget
	 *     Widget returns Widget
	 *
	 * Constraint:
	 *     (name=EString widgettype=[WidgetType|EString] (widgetelements+=ContentElement widgetelements+=ContentElement*)?)
	 */
	protected void sequence_Widget(ISerializationContext context, Widget semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
