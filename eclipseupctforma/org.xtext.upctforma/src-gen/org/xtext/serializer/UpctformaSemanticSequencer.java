/*
 * generated by Xtext 2.12.0
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.services.UpctformaGrammarAccess;
import upctforma.AggregatedType;
import upctforma.Animation;
import upctforma.Argument;
import upctforma.Column;
import upctforma.Composite;
import upctforma.CompositeArgument;
import upctforma.ContentDefinition;
import upctforma.ContentElement;
import upctforma.DragAndDrop;
import upctforma.Fixed;
import upctforma.Image;
import upctforma.Import;
import upctforma.ListType;
import upctforma.Paragraph;
import upctforma.Row;
import upctforma.Section;
import upctforma.SimpleElement;
import upctforma.SimpleType;
import upctforma.Tab;
import upctforma.TemplateDef;
import upctforma.Text;
import upctforma.Type;
import upctforma.Unit;
import upctforma.UpctformaPackage;
import upctforma.UseTemplate;
import upctforma.Variable;
import upctforma.Video;
import upctforma.Widget;
import upctforma.WidgetType;

@SuppressWarnings("all")
public class UpctformaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UpctformaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == UpctformaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UpctformaPackage.AGGREGATED_TYPE:
				sequence_AggregatedType(context, (AggregatedType) semanticObject); 
				return; 
			case UpctformaPackage.ANIMATION:
				sequence_Animation(context, (Animation) semanticObject); 
				return; 
			case UpctformaPackage.ARGUMENT:
				sequence_Argument_Impl(context, (Argument) semanticObject); 
				return; 
			case UpctformaPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case UpctformaPackage.COMPOSITE:
				sequence_Composite_Impl(context, (Composite) semanticObject); 
				return; 
			case UpctformaPackage.COMPOSITE_ARGUMENT:
				sequence_CompositeArgument_Impl(context, (CompositeArgument) semanticObject); 
				return; 
			case UpctformaPackage.CONTENT_DEFINITION:
				sequence_ContentDefinition(context, (ContentDefinition) semanticObject); 
				return; 
			case UpctformaPackage.CONTENT_ELEMENT:
				sequence_ContentElement_Impl(context, (ContentElement) semanticObject); 
				return; 
			case UpctformaPackage.DRAG_AND_DROP:
				sequence_DragAndDrop(context, (DragAndDrop) semanticObject); 
				return; 
			case UpctformaPackage.FIXED:
				sequence_Fixed(context, (Fixed) semanticObject); 
				return; 
			case UpctformaPackage.IMAGE:
				sequence_Image(context, (Image) semanticObject); 
				return; 
			case UpctformaPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case UpctformaPackage.LIST_TYPE:
				sequence_ListType(context, (ListType) semanticObject); 
				return; 
			case UpctformaPackage.PARAGRAPH:
				sequence_Paragraph(context, (Paragraph) semanticObject); 
				return; 
			case UpctformaPackage.PARAMETER:
				sequence_Parameter_Impl(context, (upctforma.Parameter) semanticObject); 
				return; 
			case UpctformaPackage.ROW:
				sequence_Row(context, (Row) semanticObject); 
				return; 
			case UpctformaPackage.SECTION:
				sequence_Section(context, (Section) semanticObject); 
				return; 
			case UpctformaPackage.SIMPLE_ELEMENT:
				sequence_SimpleArgument_Impl(context, (SimpleElement) semanticObject); 
				return; 
			case UpctformaPackage.SIMPLE_TYPE:
				sequence_SimpleType(context, (SimpleType) semanticObject); 
				return; 
			case UpctformaPackage.TAB:
				sequence_Tab(context, (Tab) semanticObject); 
				return; 
			case UpctformaPackage.TEMPLATE_DEF:
				sequence_TemplateDef(context, (TemplateDef) semanticObject); 
				return; 
			case UpctformaPackage.TEXT:
				sequence_Text(context, (Text) semanticObject); 
				return; 
			case UpctformaPackage.TYPE:
				sequence_Type_Impl(context, (Type) semanticObject); 
				return; 
			case UpctformaPackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case UpctformaPackage.USE_TEMPLATE:
				sequence_UseTemplate(context, (UseTemplate) semanticObject); 
				return; 
			case UpctformaPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case UpctformaPackage.VIDEO:
				sequence_Video(context, (Video) semanticObject); 
				return; 
			case UpctformaPackage.WIDGET:
				sequence_Widget(context, (Widget) semanticObject); 
				return; 
			case UpctformaPackage.WIDGET_TYPE:
				sequence_WidgetType(context, (WidgetType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Type returns AggregatedType
	 *     AggregatedType returns AggregatedType
	 *
	 * Constraint:
	 *     (name=EString (type+=SimpleType type+=SimpleType*)?)
	 */
	protected void sequence_AggregatedType(ISerializationContext context, AggregatedType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns Animation
	 *     Animation returns Animation
	 *
	 * Constraint:
	 *     (width=EString? image=EString? (arguments+=SimpleArgument arguments+=SimpleArgument*)?)
	 */
	protected void sequence_Animation(ISerializationContext context, Animation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns Argument
	 *     Argument_Impl returns Argument
	 *
	 * Constraint:
	 *     {Argument}
	 */
	protected void sequence_Argument_Impl(ISerializationContext context, Argument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Column
	 *     Column returns Column
	 *
	 * Constraint:
	 *     (width=EString? (elements+=ContentElement elements+=ContentElement*)?)
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns CompositeArgument
	 *     CompositeArgument_Impl returns CompositeArgument
	 *
	 * Constraint:
	 *     (arguments+=SimpleArgument arguments+=SimpleArgument*)?
	 */
	protected void sequence_CompositeArgument_Impl(ISerializationContext context, CompositeArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Composite
	 *     Composite_Impl returns Composite
	 *
	 * Constraint:
	 *     {Composite}
	 */
	protected void sequence_Composite_Impl(ISerializationContext context, Composite semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentDefinition returns ContentDefinition
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         name=QualifiedName? 
	 *         (imports+=Import imports+=Import*)? 
	 *         (types+=Type types+=Type*)? 
	 *         (templates+=TemplateDef templates+=TemplateDef*)? 
	 *         unit=Unit?
	 *     )
	 */
	protected void sequence_ContentDefinition(ISerializationContext context, ContentDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns ContentElement
	 *     ContentElement_Impl returns ContentElement
	 *
	 * Constraint:
	 *     {ContentElement}
	 */
	protected void sequence_ContentElement_Impl(ISerializationContext context, ContentElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns DragAndDrop
	 *     DragAndDrop returns DragAndDrop
	 *
	 * Constraint:
	 *     (arguments+=SimpleArgument arguments+=SimpleArgument*)?
	 */
	protected void sequence_DragAndDrop(ISerializationContext context, DragAndDrop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Fixed
	 *     ContentElement returns Fixed
	 *     Fixed returns Fixed
	 *
	 * Constraint:
	 *     type=[Type|EString]?
	 */
	protected void sequence_Fixed(ISerializationContext context, Fixed semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Image
	 *     Argument returns Image
	 *     SimpleArgument returns Image
	 *     Image returns Image
	 *
	 * Constraint:
	 *     url=EString?
	 */
	protected void sequence_Image(ISerializationContext context, Image semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ListType
	 *     ListType returns ListType
	 *
	 * Constraint:
	 *     (name=EString listtype=[SimpleType|EString]?)
	 */
	protected void sequence_ListType(ISerializationContext context, ListType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Paragraph returns Paragraph
	 *
	 * Constraint:
	 *     text=EString?
	 */
	protected void sequence_Paragraph(ISerializationContext context, Paragraph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *     ContentElement returns Parameter
	 *     Parameter_Impl returns Parameter
	 *
	 * Constraint:
	 *     {Parameter}
	 */
	protected void sequence_Parameter_Impl(ISerializationContext context, upctforma.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Row
	 *     Row returns Row
	 *
	 * Constraint:
	 *     ((columns+=Column columns+=Column*)? usetemplate=UseTemplate?)
	 */
	protected void sequence_Row(ISerializationContext context, Row semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns Section
	 *
	 * Constraint:
	 *     (name=EString image=EString? title=EString? (rows+=Row rows+=Row*)?)
	 */
	protected void sequence_Section(ISerializationContext context, Section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns SimpleElement
	 *     Argument returns SimpleElement
	 *     SimpleArgument returns SimpleElement
	 *     SimpleArgument_Impl returns SimpleElement
	 *
	 * Constraint:
	 *     {SimpleElement}
	 */
	protected void sequence_SimpleArgument_Impl(ISerializationContext context, SimpleElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns SimpleType
	 *     SimpleType returns SimpleType
	 *
	 * Constraint:
	 *     (name=EString type=TypeSimpleElement?)
	 */
	protected void sequence_SimpleType(ISerializationContext context, SimpleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns Tab
	 *     Tab returns Tab
	 *
	 * Constraint:
	 *     (arguments+=SimpleArgument arguments+=SimpleArgument*)?
	 */
	protected void sequence_Tab(ISerializationContext context, Tab semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemplateDef returns TemplateDef
	 *
	 * Constraint:
	 *     (name=EString (rows+=Row rows+=Row*)?)
	 */
	protected void sequence_TemplateDef(ISerializationContext context, TemplateDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Text
	 *     Argument returns Text
	 *     SimpleArgument returns Text
	 *     Text returns Text
	 *
	 * Constraint:
	 *     (paragraphs+=Paragraph paragraphs+=Paragraph*)
	 */
	protected void sequence_Text(ISerializationContext context, Text semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *     Type_Impl returns Type
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_Type_Impl(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_ImplAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (name=EString author=EString sections+=Section sections+=Section*)
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UseTemplate returns UseTemplate
	 *
	 * Constraint:
	 *     (typetemplate=[TemplateDef|EString]? (arguments+=Argument arguments+=Argument*)?)
	 */
	protected void sequence_UseTemplate(ISerializationContext context, UseTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Variable
	 *     ContentElement returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     type=[Type|EString]?
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Video
	 *     Argument returns Video
	 *     SimpleArgument returns Video
	 *     Video returns Video
	 *
	 * Constraint:
	 *     url=EString?
	 */
	protected void sequence_Video(ISerializationContext context, Video semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns WidgetType
	 *     WidgetType returns WidgetType
	 *
	 * Constraint:
	 *     (name=EString (parameters+=Parameter parameters+=Parameter*)?)
	 */
	protected void sequence_WidgetType(ISerializationContext context, WidgetType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Widget
	 *     Argument returns Widget
	 *     Widget returns Widget
	 *
	 * Constraint:
	 *     (name=EString widgettype=[WidgetType|EString] (widgetarguments+=Argument widgetarguments+=Argument*)?)
	 */
	protected void sequence_Widget(ISerializationContext context, Widget semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
