/*
 * generated by Xtext 2.12.0
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.services.UpctformagamiGrammarAccess;
import upctforma.AggregatedType;
import upctforma.Animation;
import upctforma.Argument;
import upctforma.Column;
import upctforma.Composite;
import upctforma.CompositeArgument;
import upctforma.ContentElement;
import upctforma.DragAndDrop;
import upctforma.Fixed;
import upctforma.Image;
import upctforma.ListType;
import upctforma.Paragraph;
import upctforma.Row;
import upctforma.Section;
import upctforma.SimpleElement;
import upctforma.SimpleType;
import upctforma.Tab;
import upctforma.TemplateDef;
import upctforma.Text;
import upctforma.Type;
import upctforma.Unit;
import upctforma.UpctformaPackage;
import upctforma.UseTemplate;
import upctforma.Variable;
import upctforma.Video;
import upctforma.Widget;
import upctforma.WidgetType;
import upctformaevalua.Assertion;
import upctformaevalua.EvaluationUnit;
import upctformaevalua.FillingAnswer;
import upctformaevalua.Final;
import upctformaevalua.Hole;
import upctformaevalua.Multiple;
import upctformaevalua.MultipleAnswer;
import upctformaevalua.Question;
import upctformaevalua.Training;
import upctformaevalua.TrueOrFalse;
import upctformaevalua.Unique;
import upctformaevalua.UniqueAnswer;
import upctformaevalua.UpctformaevaluaPackage;
import upctformagami.Badge;
import upctformagami.BadgeUnit;
import upctformagami.Gamification;
import upctformagami.Import;
import upctformagami.Mission;
import upctformagami.Point;
import upctformagami.UnitPoint;
import upctformagami.UpctformagamiPackage;
import upctformagami.WidgetDefPoint;

@SuppressWarnings("all")
public class UpctformagamiSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UpctformagamiGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == UpctformaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UpctformaPackage.AGGREGATED_TYPE:
				sequence_AggregatedType(context, (AggregatedType) semanticObject); 
				return; 
			case UpctformaPackage.ANIMATION:
				sequence_Animation(context, (Animation) semanticObject); 
				return; 
			case UpctformaPackage.ARGUMENT:
				sequence_Argument_Impl(context, (Argument) semanticObject); 
				return; 
			case UpctformaPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case UpctformaPackage.COMPOSITE:
				sequence_Composite_Impl(context, (Composite) semanticObject); 
				return; 
			case UpctformaPackage.COMPOSITE_ARGUMENT:
				sequence_CompositeArgument_Impl(context, (CompositeArgument) semanticObject); 
				return; 
			case UpctformaPackage.CONTENT_ELEMENT:
				sequence_ContentElement_Impl(context, (ContentElement) semanticObject); 
				return; 
			case UpctformaPackage.DRAG_AND_DROP:
				sequence_DragAndDrop(context, (DragAndDrop) semanticObject); 
				return; 
			case UpctformaPackage.FIXED:
				sequence_Fixed(context, (Fixed) semanticObject); 
				return; 
			case UpctformaPackage.IMAGE:
				sequence_Image(context, (Image) semanticObject); 
				return; 
			case UpctformaPackage.LIST_TYPE:
				sequence_ListType(context, (ListType) semanticObject); 
				return; 
			case UpctformaPackage.PARAGRAPH:
				sequence_Paragraph(context, (Paragraph) semanticObject); 
				return; 
			case UpctformaPackage.PARAMETER:
				sequence_Parameter_Impl(context, (upctforma.Parameter) semanticObject); 
				return; 
			case UpctformaPackage.ROW:
				sequence_Row(context, (Row) semanticObject); 
				return; 
			case UpctformaPackage.SECTION:
				sequence_Section(context, (Section) semanticObject); 
				return; 
			case UpctformaPackage.SIMPLE_ELEMENT:
				sequence_SimpleElement_Impl(context, (SimpleElement) semanticObject); 
				return; 
			case UpctformaPackage.SIMPLE_TYPE:
				sequence_SimpleType(context, (SimpleType) semanticObject); 
				return; 
			case UpctformaPackage.TAB:
				sequence_Tab(context, (Tab) semanticObject); 
				return; 
			case UpctformaPackage.TEMPLATE_DEF:
				sequence_TemplateDef(context, (TemplateDef) semanticObject); 
				return; 
			case UpctformaPackage.TEXT:
				sequence_Text(context, (Text) semanticObject); 
				return; 
			case UpctformaPackage.TYPE:
				sequence_Type_Impl(context, (Type) semanticObject); 
				return; 
			case UpctformaPackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case UpctformaPackage.USE_TEMPLATE:
				sequence_UseTemplate(context, (UseTemplate) semanticObject); 
				return; 
			case UpctformaPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case UpctformaPackage.VIDEO:
				sequence_Video(context, (Video) semanticObject); 
				return; 
			case UpctformaPackage.WIDGET:
				sequence_Widget(context, (Widget) semanticObject); 
				return; 
			case UpctformaPackage.WIDGET_TYPE:
				sequence_WidgetType(context, (WidgetType) semanticObject); 
				return; 
			}
		else if (epackage == UpctformaevaluaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UpctformaevaluaPackage.ASSERTION:
				sequence_Assertion(context, (Assertion) semanticObject); 
				return; 
			case UpctformaevaluaPackage.EVALUATION_UNIT:
				sequence_EvaluationUnit_Impl(context, (EvaluationUnit) semanticObject); 
				return; 
			case UpctformaevaluaPackage.FILLING_ANSWER:
				sequence_FillingAnswer(context, (FillingAnswer) semanticObject); 
				return; 
			case UpctformaevaluaPackage.FINAL:
				sequence_Final(context, (Final) semanticObject); 
				return; 
			case UpctformaevaluaPackage.HOLE:
				sequence_Hole(context, (Hole) semanticObject); 
				return; 
			case UpctformaevaluaPackage.MULTIPLE:
				sequence_Multiple(context, (Multiple) semanticObject); 
				return; 
			case UpctformaevaluaPackage.MULTIPLE_ANSWER:
				sequence_MultipleAnswer(context, (MultipleAnswer) semanticObject); 
				return; 
			case UpctformaevaluaPackage.PARAGRAPH:
				sequence_Paragraph0(context, (upctformaevalua.Paragraph) semanticObject); 
				return; 
			case UpctformaevaluaPackage.QUESTION:
				sequence_Question_Impl(context, (Question) semanticObject); 
				return; 
			case UpctformaevaluaPackage.TRAINING:
				sequence_Training(context, (Training) semanticObject); 
				return; 
			case UpctformaevaluaPackage.TRUE_OR_FALSE:
				sequence_TrueOrFalse(context, (TrueOrFalse) semanticObject); 
				return; 
			case UpctformaevaluaPackage.UNIQUE:
				sequence_Unique(context, (Unique) semanticObject); 
				return; 
			case UpctformaevaluaPackage.UNIQUE_ANSWER:
				sequence_UniqueAnswer(context, (UniqueAnswer) semanticObject); 
				return; 
			}
		else if (epackage == UpctformagamiPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UpctformagamiPackage.BADGE:
				sequence_Badge(context, (Badge) semanticObject); 
				return; 
			case UpctformagamiPackage.BADGE_UNIT:
				sequence_BadgeUnit(context, (BadgeUnit) semanticObject); 
				return; 
			case UpctformagamiPackage.GAMIFICATION:
				sequence_Gamification(context, (Gamification) semanticObject); 
				return; 
			case UpctformagamiPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case UpctformagamiPackage.MISSION:
				sequence_Mission(context, (Mission) semanticObject); 
				return; 
			case UpctformagamiPackage.POINT:
				sequence_Point(context, (Point) semanticObject); 
				return; 
			case UpctformagamiPackage.UNIT_POINT:
				sequence_UnitPoint(context, (UnitPoint) semanticObject); 
				return; 
			case UpctformagamiPackage.WIDGET_DEF_POINT:
				sequence_WidgetDefPoint(context, (WidgetDefPoint) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Type returns AggregatedType
	 *     AggregatedType returns AggregatedType
	 *
	 * Constraint:
	 *     (name=EString (type+=SimpleType type+=SimpleType*)?)
	 */
	protected void sequence_AggregatedType(ISerializationContext context, AggregatedType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns Animation
	 *     Animation returns Animation
	 *
	 * Constraint:
	 *     (width=EString? image=EString? (arguments+=SimpleElement arguments+=SimpleElement*)?)
	 */
	protected void sequence_Animation(ISerializationContext context, Animation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns Argument
	 *     Argument_Impl returns Argument
	 *
	 * Constraint:
	 *     {Argument}
	 */
	protected void sequence_Argument_Impl(ISerializationContext context, Argument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assertion returns Assertion
	 *
	 * Constraint:
	 *     (value?='value'? text=EString?)
	 */
	protected void sequence_Assertion(ISerializationContext context, Assertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BadgeUnit returns BadgeUnit
	 *
	 * Constraint:
	 *     (type=TypeRule? badge=[Badge|EString]?)
	 */
	protected void sequence_BadgeUnit(ISerializationContext context, BadgeUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Badge returns Badge
	 *
	 * Constraint:
	 *     (name=EString description=EString? url=EString?)
	 */
	protected void sequence_Badge(ISerializationContext context, Badge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Column
	 *     Column returns Column
	 *
	 * Constraint:
	 *     (width=EString? (elements+=ContentElement elements+=ContentElement*)?)
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns CompositeArgument
	 *     CompositeArgument_Impl returns CompositeArgument
	 *
	 * Constraint:
	 *     (arguments+=SimpleElement arguments+=SimpleElement*)?
	 */
	protected void sequence_CompositeArgument_Impl(ISerializationContext context, CompositeArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Composite
	 *     Composite_Impl returns Composite
	 *
	 * Constraint:
	 *     {Composite}
	 */
	protected void sequence_Composite_Impl(ISerializationContext context, Composite semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns ContentElement
	 *     ContentElement_Impl returns ContentElement
	 *
	 * Constraint:
	 *     {ContentElement}
	 */
	protected void sequence_ContentElement_Impl(ISerializationContext context, ContentElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns DragAndDrop
	 *     DragAndDrop returns DragAndDrop
	 *
	 * Constraint:
	 *     (arguments+=SimpleElement arguments+=SimpleElement*)?
	 */
	protected void sequence_DragAndDrop(ISerializationContext context, DragAndDrop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EvaluationUnit returns EvaluationUnit
	 *     EvaluationUnit_Impl returns EvaluationUnit
	 *
	 * Constraint:
	 *     (name=EString numberquestions=EInt? (questions+=Question questions+=Question*)?)
	 */
	protected void sequence_EvaluationUnit_Impl(ISerializationContext context, EvaluationUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Question returns FillingAnswer
	 *     FillingAnswer returns FillingAnswer
	 *
	 * Constraint:
	 *     (correctfeedback=EString? incorrectfeedback=EString? (holes+=Hole holes+=Hole*)?)
	 */
	protected void sequence_FillingAnswer(ISerializationContext context, FillingAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EvaluationUnit returns Final
	 *     Final returns Final
	 *
	 * Constraint:
	 *     (name=EString numberquestions=EInt? (questions+=Question questions+=Question*)?)
	 */
	protected void sequence_Final(ISerializationContext context, Final semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Fixed
	 *     ContentElement returns Fixed
	 *     Fixed returns Fixed
	 *
	 * Constraint:
	 *     type=[Type|EString]
	 */
	protected void sequence_Fixed(ISerializationContext context, Fixed semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.PARAMETER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFixedAccess().getTypeTypeEStringParserRuleCall_3_0_1(), semanticObject.eGet(UpctformaPackage.Literals.PARAMETER__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Gamification returns Gamification
	 *
	 * Constraint:
	 *     (
	 *         (imports+=Import imports+=Import*)? 
	 *         (badges+=Badge badges+=Badge*)? 
	 *         (widgets+=WidgetDefPoint widgets+=WidgetDefPoint*)? 
	 *         (units+=UnitPoint units+=UnitPoint*)?
	 *     )
	 */
	protected void sequence_Gamification(ISerializationContext context, Gamification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Hole returns Hole
	 *
	 * Constraint:
	 *     (text=EString? type=TypeHole?)
	 */
	protected void sequence_Hole(ISerializationContext context, Hole semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Image
	 *     Argument returns Image
	 *     SimpleElement returns Image
	 *     Image returns Image
	 *
	 * Constraint:
	 *     url=EString?
	 */
	protected void sequence_Image(ISerializationContext context, Image semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformagamiPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformagamiPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ListType
	 *     ListType returns ListType
	 *
	 * Constraint:
	 *     (name=EString listtype=[SimpleType|EString]?)
	 */
	protected void sequence_ListType(ISerializationContext context, ListType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Mission returns Mission
	 *
	 * Constraint:
	 *     (type=TypeMissions? InitialScore=EDouble? FinalScore=EDouble? nextunit=[Unit|EString]? nexteval=[EvaluationUnit|EString]?)
	 */
	protected void sequence_Mission(ISerializationContext context, Mission semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Question returns MultipleAnswer
	 *     MultipleAnswer returns MultipleAnswer
	 *
	 * Constraint:
	 *     (correctfeedback=EString? incorrectfeedback=EString? statements=Paragraph0 (answers+=Multiple answers+=Multiple*)?)
	 */
	protected void sequence_MultipleAnswer(ISerializationContext context, MultipleAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiple returns Multiple
	 *
	 * Constraint:
	 *     (value?='value'? text=EString?)
	 */
	protected void sequence_Multiple(ISerializationContext context, Multiple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Paragraph0 returns Paragraph
	 *
	 * Constraint:
	 *     text=EString?
	 */
	protected void sequence_Paragraph0(ISerializationContext context, upctformaevalua.Paragraph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Paragraph returns Paragraph
	 *
	 * Constraint:
	 *     text=EString?
	 */
	protected void sequence_Paragraph(ISerializationContext context, Paragraph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *     ContentElement returns Parameter
	 *     Parameter_Impl returns Parameter
	 *
	 * Constraint:
	 *     type=[Type|EString]
	 */
	protected void sequence_Parameter_Impl(ISerializationContext context, upctforma.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.PARAMETER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameter_ImplAccess().getTypeTypeEStringParserRuleCall_3_0_1(), semanticObject.eGet(UpctformaPackage.Literals.PARAMETER__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Point returns Point
	 *
	 * Constraint:
	 *     (type=TypeRule? points=EInt? attempt=EInt? InitialScore=EDouble? FinalScore=EDouble?)
	 */
	protected void sequence_Point(ISerializationContext context, Point semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Question returns Question
	 *     Question_Impl returns Question
	 *
	 * Constraint:
	 *     (correctfeedback=EString? incorrectfeedback=EString?)
	 */
	protected void sequence_Question_Impl(ISerializationContext context, Question semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Row
	 *     Row returns Row
	 *
	 * Constraint:
	 *     ((columns+=Column columns+=Column*)? usetemplate=UseTemplate?)
	 */
	protected void sequence_Row(ISerializationContext context, Row semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns Section
	 *
	 * Constraint:
	 *     (name=EString image=EString? title=EString? (rows+=Row rows+=Row*)?)
	 */
	protected void sequence_Section(ISerializationContext context, Section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns SimpleElement
	 *     Argument returns SimpleElement
	 *     SimpleElement returns SimpleElement
	 *     SimpleElement_Impl returns SimpleElement
	 *
	 * Constraint:
	 *     {SimpleElement}
	 */
	protected void sequence_SimpleElement_Impl(ISerializationContext context, SimpleElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns SimpleType
	 *     SimpleType returns SimpleType
	 *
	 * Constraint:
	 *     (name=EString type=TypeSimpleElement?)
	 */
	protected void sequence_SimpleType(ISerializationContext context, SimpleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns Tab
	 *     Tab returns Tab
	 *
	 * Constraint:
	 *     (arguments+=SimpleElement arguments+=SimpleElement*)?
	 */
	protected void sequence_Tab(ISerializationContext context, Tab semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemplateDef returns TemplateDef
	 *
	 * Constraint:
	 *     (name=EString (rows+=Row rows+=Row*)?)
	 */
	protected void sequence_TemplateDef(ISerializationContext context, TemplateDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Text
	 *     Argument returns Text
	 *     SimpleElement returns Text
	 *     Text returns Text
	 *
	 * Constraint:
	 *     (paragraphs+=Paragraph paragraphs+=Paragraph*)
	 */
	protected void sequence_Text(ISerializationContext context, Text semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EvaluationUnit returns Training
	 *     Training returns Training
	 *
	 * Constraint:
	 *     (name=EString numberquestions=EInt? Attempts=EInt? grade=TypeGrade? (questions+=Question questions+=Question*)?)
	 */
	protected void sequence_Training(ISerializationContext context, Training semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Question returns TrueOrFalse
	 *     TrueOrFalse returns TrueOrFalse
	 *
	 * Constraint:
	 *     (correctfeedback=EString? incorrectfeedback=EString? (assertions+=Assertion assertions+=Assertion*)?)
	 */
	protected void sequence_TrueOrFalse(ISerializationContext context, TrueOrFalse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *     Type_Impl returns Type
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_Type_Impl(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_ImplAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Question returns UniqueAnswer
	 *     UniqueAnswer returns UniqueAnswer
	 *
	 * Constraint:
	 *     (correctfeedback=EString? incorrectfeedback=EString? correctanswer=EInt? statements=Paragraph0 (answers+=Unique answers+=Unique*)?)
	 */
	protected void sequence_UniqueAnswer(ISerializationContext context, UniqueAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unique returns Unique
	 *
	 * Constraint:
	 *     text=EString?
	 */
	protected void sequence_Unique(ISerializationContext context, Unique semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitPoint returns UnitPoint
	 *
	 * Constraint:
	 *     (
	 *         state=TypeState? 
	 *         unitref=[Unit|EString]? 
	 *         evalref=[EvaluationUnit|EString]? 
	 *         URL=EString? 
	 *         image=EString? 
	 *         (defbadges+=BadgeUnit defbadges+=BadgeUnit*)? 
	 *         (pointsunit+=Point pointsunit+=Point*)? 
	 *         (missions+=Mission missions+=Mission*)?
	 *     )
	 */
	protected void sequence_UnitPoint(ISerializationContext context, UnitPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (name=EString author=EString? sections+=Section sections+=Section*)
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UseTemplate returns UseTemplate
	 *
	 * Constraint:
	 *     (typetemplate=[TemplateDef|EString]? (arguments+=Argument arguments+=Argument*)?)
	 */
	protected void sequence_UseTemplate(ISerializationContext context, UseTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Variable
	 *     ContentElement returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     type=[Type|EString]
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.PARAMETER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getTypeTypeEStringParserRuleCall_3_0_1(), semanticObject.eGet(UpctformaPackage.Literals.PARAMETER__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Video
	 *     Argument returns Video
	 *     SimpleElement returns Video
	 *     Video returns Video
	 *
	 * Constraint:
	 *     url=EString?
	 */
	protected void sequence_Video(ISerializationContext context, Video semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WidgetDefPoint returns WidgetDefPoint
	 *
	 * Constraint:
	 *     (
	 *         (widgetref+=[WidgetType|EString] widgetref+=[WidgetType|EString]*)? 
	 *         (unitref+=[Unit|EString] unitref+=[Unit|EString]*)? 
	 *         (pointswidgetdef+=Point pointswidgetdef+=Point*)?
	 *     )
	 */
	protected void sequence_WidgetDefPoint(ISerializationContext context, WidgetDefPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns WidgetType
	 *     WidgetType returns WidgetType
	 *
	 * Constraint:
	 *     (name=EString (parameters+=Parameter parameters+=Parameter*)?)
	 */
	protected void sequence_WidgetType(ISerializationContext context, WidgetType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Widget
	 *     Argument returns Widget
	 *     Widget returns Widget
	 *
	 * Constraint:
	 *     (name=EString widgettype=[WidgetType|EString] (widgetarguments+=Argument widgetarguments+=Argument*)?)
	 */
	protected void sequence_Widget(ISerializationContext context, Widget semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
