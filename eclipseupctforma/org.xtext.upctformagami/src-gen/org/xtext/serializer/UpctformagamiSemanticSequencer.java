/*
 * generated by Xtext 2.12.0
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.services.UpctformagamiGrammarAccess;
import upctforma.Column;
import upctforma.Composite;
import upctforma.CompositeType;
import upctforma.ContentElement;
import upctforma.Field;
import upctforma.FieldValue;
import upctforma.Game;
import upctforma.Image;
import upctforma.ListType;
import upctforma.ListValue;
import upctforma.Paragraph;
import upctforma.PlaceHolder;
import upctforma.RecordType;
import upctforma.RecordValue;
import upctforma.Row;
import upctforma.Section;
import upctforma.SimpleElement;
import upctforma.SimpleType;
import upctforma.TemplateDef;
import upctforma.Text;
import upctforma.Type;
import upctforma.Unit;
import upctforma.UpctformaPackage;
import upctforma.UseTemplate;
import upctforma.Video;
import upctforma.Widget;
import upctforma.WidgetType;
import upctformaevalua.Assertion;
import upctformaevalua.EvaluationUnit;
import upctformaevalua.FillingAnswer;
import upctformaevalua.Final;
import upctformaevalua.Hole;
import upctformaevalua.Multiple;
import upctformaevalua.MultipleAnswer;
import upctformaevalua.Question;
import upctformaevalua.Training;
import upctformaevalua.TrueOrFalse;
import upctformaevalua.Unique;
import upctformaevalua.UniqueAnswer;
import upctformaevalua.UpctformaevaluaPackage;
import upctformagami.Badge;
import upctformagami.Gamification;
import upctformagami.Import;
import upctformagami.Mission;
import upctformagami.PointAchievement;
import upctformagami.ScoreRange;
import upctformagami.UnitBadge;
import upctformagami.UnitGamify;
import upctformagami.UpctformagamiPackage;
import upctformagami.WidgetGamify;

@SuppressWarnings("all")
public class UpctformagamiSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UpctformagamiGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == UpctformaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UpctformaPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case UpctformaPackage.COMPOSITE:
				sequence_Composite_Impl(context, (Composite) semanticObject); 
				return; 
			case UpctformaPackage.COMPOSITE_TYPE:
				sequence_CompositeType_Impl(context, (CompositeType) semanticObject); 
				return; 
			case UpctformaPackage.CONTENT_ELEMENT:
				sequence_ContentElement_Impl(context, (ContentElement) semanticObject); 
				return; 
			case UpctformaPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case UpctformaPackage.FIELD_VALUE:
				sequence_FieldValue(context, (FieldValue) semanticObject); 
				return; 
			case UpctformaPackage.GAME:
				sequence_Game(context, (Game) semanticObject); 
				return; 
			case UpctformaPackage.IMAGE:
				sequence_Image(context, (Image) semanticObject); 
				return; 
			case UpctformaPackage.LIST_TYPE:
				sequence_ListType(context, (ListType) semanticObject); 
				return; 
			case UpctformaPackage.LIST_VALUE:
				sequence_ListValue(context, (ListValue) semanticObject); 
				return; 
			case UpctformaPackage.PARAGRAPH:
				sequence_Paragraph(context, (Paragraph) semanticObject); 
				return; 
			case UpctformaPackage.PLACE_HOLDER:
				sequence_PlaceHolder(context, (PlaceHolder) semanticObject); 
				return; 
			case UpctformaPackage.RECORD_TYPE:
				sequence_RecordType(context, (RecordType) semanticObject); 
				return; 
			case UpctformaPackage.RECORD_VALUE:
				sequence_RecordValue(context, (RecordValue) semanticObject); 
				return; 
			case UpctformaPackage.ROW:
				sequence_Row(context, (Row) semanticObject); 
				return; 
			case UpctformaPackage.SECTION:
				sequence_Section(context, (Section) semanticObject); 
				return; 
			case UpctformaPackage.SIMPLE_ELEMENT:
				sequence_SimpleElement_Impl(context, (SimpleElement) semanticObject); 
				return; 
			case UpctformaPackage.SIMPLE_TYPE:
				sequence_SimpleType(context, (SimpleType) semanticObject); 
				return; 
			case UpctformaPackage.TEMPLATE_DEF:
				sequence_TemplateDef(context, (TemplateDef) semanticObject); 
				return; 
			case UpctformaPackage.TEXT:
				sequence_Text(context, (Text) semanticObject); 
				return; 
			case UpctformaPackage.TYPE:
				sequence_Type_Impl(context, (Type) semanticObject); 
				return; 
			case UpctformaPackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case UpctformaPackage.USE_TEMPLATE:
				sequence_UseTemplate(context, (UseTemplate) semanticObject); 
				return; 
			case UpctformaPackage.VIDEO:
				sequence_Video(context, (Video) semanticObject); 
				return; 
			case UpctformaPackage.WIDGET:
				sequence_Widget(context, (Widget) semanticObject); 
				return; 
			case UpctformaPackage.WIDGET_TYPE:
				sequence_WidgetType(context, (WidgetType) semanticObject); 
				return; 
			}
		else if (epackage == UpctformaevaluaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UpctformaevaluaPackage.ASSERTION:
				sequence_Assertion(context, (Assertion) semanticObject); 
				return; 
			case UpctformaevaluaPackage.EVALUATION_UNIT:
				sequence_EvaluationUnit_Impl(context, (EvaluationUnit) semanticObject); 
				return; 
			case UpctformaevaluaPackage.FILLING_ANSWER:
				sequence_FillingAnswer(context, (FillingAnswer) semanticObject); 
				return; 
			case UpctformaevaluaPackage.FINAL:
				sequence_Final(context, (Final) semanticObject); 
				return; 
			case UpctformaevaluaPackage.HOLE:
				sequence_Hole(context, (Hole) semanticObject); 
				return; 
			case UpctformaevaluaPackage.MULTIPLE:
				sequence_Multiple(context, (Multiple) semanticObject); 
				return; 
			case UpctformaevaluaPackage.MULTIPLE_ANSWER:
				sequence_MultipleAnswer(context, (MultipleAnswer) semanticObject); 
				return; 
			case UpctformaevaluaPackage.PARAGRAPH:
				sequence_Paragraph0(context, (upctformaevalua.Paragraph) semanticObject); 
				return; 
			case UpctformaevaluaPackage.QUESTION:
				sequence_Question_Impl(context, (Question) semanticObject); 
				return; 
			case UpctformaevaluaPackage.TRAINING:
				sequence_Training(context, (Training) semanticObject); 
				return; 
			case UpctformaevaluaPackage.TRUE_OR_FALSE:
				sequence_TrueOrFalse(context, (TrueOrFalse) semanticObject); 
				return; 
			case UpctformaevaluaPackage.UNIQUE:
				sequence_Unique(context, (Unique) semanticObject); 
				return; 
			case UpctformaevaluaPackage.UNIQUE_ANSWER:
				sequence_UniqueAnswer(context, (UniqueAnswer) semanticObject); 
				return; 
			}
		else if (epackage == UpctformagamiPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UpctformagamiPackage.BADGE:
				sequence_Badge(context, (Badge) semanticObject); 
				return; 
			case UpctformagamiPackage.GAMIFICATION:
				sequence_Gamification(context, (Gamification) semanticObject); 
				return; 
			case UpctformagamiPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case UpctformagamiPackage.MISSION:
				sequence_Mission(context, (Mission) semanticObject); 
				return; 
			case UpctformagamiPackage.POINT_ACHIEVEMENT:
				sequence_PointAchievement(context, (PointAchievement) semanticObject); 
				return; 
			case UpctformagamiPackage.SCORE_RANGE:
				sequence_ScoreRange(context, (ScoreRange) semanticObject); 
				return; 
			case UpctformagamiPackage.UNIT_BADGE:
				sequence_UnitBadge(context, (UnitBadge) semanticObject); 
				return; 
			case UpctformagamiPackage.UNIT_GAMIFY:
				sequence_UnitGamify(context, (UnitGamify) semanticObject); 
				return; 
			case UpctformagamiPackage.WIDGET_GAMIFY:
				sequence_WidgetGamify(context, (WidgetGamify) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Assertion returns Assertion
	 *
	 * Constraint:
	 *     (value?='value'? text=EString?)
	 */
	protected void sequence_Assertion(ISerializationContext context, Assertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Badge returns Badge
	 *
	 * Constraint:
	 *     (name=EString description=EString? url=EString?)
	 */
	protected void sequence_Badge(ISerializationContext context, Badge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Column
	 *     Column returns Column
	 *
	 * Constraint:
	 *     (width=EString? (elements+=ContentElement elements+=ContentElement*)?)
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns CompositeType
	 *     CompositeType_Impl returns CompositeType
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_CompositeType_Impl(ISerializationContext context, CompositeType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompositeType_ImplAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Composite
	 *     Composite_Impl returns Composite
	 *
	 * Constraint:
	 *     {Composite}
	 */
	protected void sequence_Composite_Impl(ISerializationContext context, Composite semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns ContentElement
	 *     ContentElement_Impl returns ContentElement
	 *
	 * Constraint:
	 *     {ContentElement}
	 */
	protected void sequence_ContentElement_Impl(ISerializationContext context, ContentElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EvaluationUnit returns EvaluationUnit
	 *     EvaluationUnit_Impl returns EvaluationUnit
	 *
	 * Constraint:
	 *     (name=EString numberquestions=EInt? (questions+=Question questions+=Question*)?)
	 */
	protected void sequence_EvaluationUnit_Impl(ISerializationContext context, EvaluationUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FieldValue returns FieldValue
	 *
	 * Constraint:
	 *     (name=EString fieldvalue=ContentElement)
	 */
	protected void sequence_FieldValue(ISerializationContext context, FieldValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.FIELD_VALUE__FIELDVALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.FIELD_VALUE__FIELDVALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldValueAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFieldValueAccess().getFieldvalueContentElementParserRuleCall_4_0(), semanticObject.getFieldvalue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (name=EString fieldtype=[Type|EString])
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.FIELD__FIELDTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.FIELD__FIELDTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFieldAccess().getFieldtypeTypeEStringParserRuleCall_4_0_1(), semanticObject.eGet(UpctformaPackage.Literals.FIELD__FIELDTYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Question returns FillingAnswer
	 *     FillingAnswer returns FillingAnswer
	 *
	 * Constraint:
	 *     (correctfeedback=EString? incorrectfeedback=EString? (holes+=Hole holes+=Hole*)?)
	 */
	protected void sequence_FillingAnswer(ISerializationContext context, FillingAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EvaluationUnit returns Final
	 *     Final returns Final
	 *
	 * Constraint:
	 *     (name=EString numberquestions=EInt? (questions+=Question questions+=Question*)?)
	 */
	protected void sequence_Final(ISerializationContext context, Final semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Game
	 *     Game returns Game
	 *
	 * Constraint:
	 *     id=EString?
	 */
	protected void sequence_Game(ISerializationContext context, Game semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Gamification returns Gamification
	 *
	 * Constraint:
	 *     (
	 *         (imports+=Import imports+=Import*)? 
	 *         (badges+=Badge badges+=Badge*)? 
	 *         (widgets+=WidgetGamify widgets+=WidgetGamify*)? 
	 *         (units+=UnitGamify units+=UnitGamify*)?
	 *     )
	 */
	protected void sequence_Gamification(ISerializationContext context, Gamification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Hole returns Hole
	 *
	 * Constraint:
	 *     (text=EString? type=TypeHole?)
	 */
	protected void sequence_Hole(ISerializationContext context, Hole semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Image
	 *     Image returns Image
	 *
	 * Constraint:
	 *     url=EString?
	 */
	protected void sequence_Image(ISerializationContext context, Image semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformagamiPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformagamiPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ListType
	 *     ListType returns ListType
	 *
	 * Constraint:
	 *     (name=EString listtype=[Type|EString])
	 */
	protected void sequence_ListType(ISerializationContext context, ListType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.LIST_TYPE__LISTTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.LIST_TYPE__LISTTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getListTypeAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getListTypeAccess().getListtypeTypeEStringParserRuleCall_4_0_1(), semanticObject.eGet(UpctformaPackage.Literals.LIST_TYPE__LISTTYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns ListValue
	 *     ListValue returns ListValue
	 *
	 * Constraint:
	 *     (listvalues+=ContentElement listvalues+=ContentElement*)
	 */
	protected void sequence_ListValue(ISerializationContext context, ListValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Mission returns Mission
	 *
	 * Constraint:
	 *     (type=TypeMissions? (missionrange+=ScoreRange missionrange+=ScoreRange*)? nextunit=[Unit|EString]? nexteval=[EvaluationUnit|EString]?)
	 */
	protected void sequence_Mission(ISerializationContext context, Mission semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Question returns MultipleAnswer
	 *     MultipleAnswer returns MultipleAnswer
	 *
	 * Constraint:
	 *     (correctfeedback=EString? incorrectfeedback=EString? statements=Paragraph0 (answers+=Multiple answers+=Multiple*)?)
	 */
	protected void sequence_MultipleAnswer(ISerializationContext context, MultipleAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiple returns Multiple
	 *
	 * Constraint:
	 *     (value?='value'? text=EString?)
	 */
	protected void sequence_Multiple(ISerializationContext context, Multiple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Paragraph0 returns Paragraph
	 *
	 * Constraint:
	 *     text=EString?
	 */
	protected void sequence_Paragraph0(ISerializationContext context, upctformaevalua.Paragraph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Paragraph returns Paragraph
	 *
	 * Constraint:
	 *     text=EString?
	 */
	protected void sequence_Paragraph(ISerializationContext context, Paragraph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns PlaceHolder
	 *     PlaceHolder returns PlaceHolder
	 *
	 * Constraint:
	 *     type=[Type|EString]
	 */
	protected void sequence_PlaceHolder(ISerializationContext context, PlaceHolder semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.PLACE_HOLDER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.PLACE_HOLDER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlaceHolderAccess().getTypeTypeEStringParserRuleCall_3_0_1(), semanticObject.eGet(UpctformaPackage.Literals.PLACE_HOLDER__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PointAchievement returns PointAchievement
	 *
	 * Constraint:
	 *     (type=TypeRule? points=EInt? attempt=EInt? (pointrange+=ScoreRange pointrange+=ScoreRange*)?)
	 */
	protected void sequence_PointAchievement(ISerializationContext context, PointAchievement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Question returns Question
	 *     Question_Impl returns Question
	 *
	 * Constraint:
	 *     (correctfeedback=EString? incorrectfeedback=EString?)
	 */
	protected void sequence_Question_Impl(ISerializationContext context, Question semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns RecordType
	 *     RecordType returns RecordType
	 *
	 * Constraint:
	 *     (name=EString recordtype+=Field recordtype+=Field*)
	 */
	protected void sequence_RecordType(ISerializationContext context, RecordType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns RecordValue
	 *     RecordValue returns RecordValue
	 *
	 * Constraint:
	 *     (recordvalues+=FieldValue recordvalues+=FieldValue*)
	 */
	protected void sequence_RecordValue(ISerializationContext context, RecordValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Row
	 *     Row returns Row
	 *
	 * Constraint:
	 *     ((columns+=Column columns+=Column*)? usetemplate=UseTemplate?)
	 */
	protected void sequence_Row(ISerializationContext context, Row semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScoreRange returns ScoreRange
	 *
	 * Constraint:
	 *     (InitialScore=EDouble? FinalScore=EDouble?)
	 */
	protected void sequence_ScoreRange(ISerializationContext context, ScoreRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns Section
	 *
	 * Constraint:
	 *     (name=EString image=EString? title=EString? (rows+=Row rows+=Row*)?)
	 */
	protected void sequence_Section(ISerializationContext context, Section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns SimpleElement
	 *     SimpleElement_Impl returns SimpleElement
	 *
	 * Constraint:
	 *     {SimpleElement}
	 */
	protected void sequence_SimpleElement_Impl(ISerializationContext context, SimpleElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns SimpleType
	 *     SimpleType returns SimpleType
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_SimpleType(ISerializationContext context, SimpleType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleTypeAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TemplateDef returns TemplateDef
	 *
	 * Constraint:
	 *     (name=EString (rows+=Row rows+=Row*)?)
	 */
	protected void sequence_TemplateDef(ISerializationContext context, TemplateDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Text
	 *     Text returns Text
	 *
	 * Constraint:
	 *     (paragraphs+=Paragraph paragraphs+=Paragraph*)
	 */
	protected void sequence_Text(ISerializationContext context, Text semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EvaluationUnit returns Training
	 *     Training returns Training
	 *
	 * Constraint:
	 *     (name=EString numberquestions=EInt? Attempts=EInt? grade=TypeGrade? (questions+=Question questions+=Question*)?)
	 */
	protected void sequence_Training(ISerializationContext context, Training semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Question returns TrueOrFalse
	 *     TrueOrFalse returns TrueOrFalse
	 *
	 * Constraint:
	 *     (correctfeedback=EString? incorrectfeedback=EString? (assertions+=Assertion assertions+=Assertion*)?)
	 */
	protected void sequence_TrueOrFalse(ISerializationContext context, TrueOrFalse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *     Type_Impl returns Type
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_Type_Impl(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UpctformaPackage.Literals.NAME_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getType_ImplAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Question returns UniqueAnswer
	 *     UniqueAnswer returns UniqueAnswer
	 *
	 * Constraint:
	 *     (correctfeedback=EString? incorrectfeedback=EString? correctanswer=EInt? statements=Paragraph0 (answers+=Unique answers+=Unique*)?)
	 */
	protected void sequence_UniqueAnswer(ISerializationContext context, UniqueAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unique returns Unique
	 *
	 * Constraint:
	 *     text=EString?
	 */
	protected void sequence_Unique(ISerializationContext context, Unique semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitBadge returns UnitBadge
	 *
	 * Constraint:
	 *     (type=TypeRule? badge=[Badge|EString]?)
	 */
	protected void sequence_UnitBadge(ISerializationContext context, UnitBadge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitGamify returns UnitGamify
	 *
	 * Constraint:
	 *     (
	 *         state=TypeState? 
	 *         unitref=[Unit|EString]? 
	 *         evalref=[EvaluationUnit|EString]? 
	 *         URL=EString? 
	 *         image=EString? 
	 *         (defbadges+=UnitBadge defbadges+=UnitBadge*)? 
	 *         (pointsunit+=PointAchievement pointsunit+=PointAchievement*)? 
	 *         (missions+=Mission missions+=Mission*)?
	 *     )
	 */
	protected void sequence_UnitGamify(ISerializationContext context, UnitGamify semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (name=EString author=EString? sections+=Section sections+=Section*)
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UseTemplate returns UseTemplate
	 *
	 * Constraint:
	 *     (typetemplate=[TemplateDef|EString]? (templateelements+=ContentElement templateelements+=ContentElement*)?)
	 */
	protected void sequence_UseTemplate(ISerializationContext context, UseTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Video
	 *     Video returns Video
	 *
	 * Constraint:
	 *     id=EString?
	 */
	protected void sequence_Video(ISerializationContext context, Video semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WidgetGamify returns WidgetGamify
	 *
	 * Constraint:
	 *     (
	 *         (widgetref+=[WidgetType|EString] widgetref+=[WidgetType|EString]*)? 
	 *         (unitref+=[Unit|EString] unitref+=[Unit|EString]*)? 
	 *         (pointswidgetdef+=PointAchievement pointswidgetdef+=PointAchievement*)?
	 *     )
	 */
	protected void sequence_WidgetGamify(ISerializationContext context, WidgetGamify semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns WidgetType
	 *     WidgetType returns WidgetType
	 *
	 * Constraint:
	 *     (name=EString widgettypeelements+=[Type|EString] widgettypeelements+=[Type|EString]*)
	 */
	protected void sequence_WidgetType(ISerializationContext context, WidgetType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentElement returns Widget
	 *     Widget returns Widget
	 *
	 * Constraint:
	 *     (name=EString widgettype=[WidgetType|EString] (widgetelements+=ContentElement widgetelements+=ContentElement*)?)
	 */
	protected void sequence_Widget(ISerializationContext context, Widget semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
